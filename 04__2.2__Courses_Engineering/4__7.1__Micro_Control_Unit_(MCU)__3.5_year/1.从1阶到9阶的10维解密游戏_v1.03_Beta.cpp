
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――Generated by xcz.
#include<stdio.h>           //引用标准输入输出函数库，如printf、getchar等，需要用到printf()。
#include<math.h>            //引用数学函数库（非必要），在本程序中取随机数范围区间时，要用到取余符号%（其实取余符号是c自带的，倒是取余函数在math.h里）。――只是怕以后要用，为了以后偷懒，就先放在这里了。免得以后再写。
#include<stdlib.h>          //引用系统函数库，里面有指针相关函数，我需要动态分配内存区地址数量or空间，即要用到malloc()和realloc()；同时也要用到里面的rand() 、srand()函数来生成随机数――在c++的头文件cstdlib.h中也有这个rand()，但好像c中只有stdlib.h中有它俩。
#include<conio.h>           //引用控制台输入输出库。我需要用到getch(),返回的是int类型。不管用cin,scanf还是getchar，都不能实时的输入按键，必须要按回车才能读进去，而按回车的话会导致显示异常，所以要实时获取键盘按键的函数。
#include<time.h>            //引用日期和时间头文件，使用当前时间做种子（我不需要短时间内生成大量随机数，而是用户每玩一次游戏生成一次；而玩两次的时间一定不同，所以两次srand播下的与时间相关的种是不同的，所以生成的伪随机序列也不会因种子的相近而相同，所以生成的伪随机数不同――我们只需要实现每场游戏的密码随机，即可）。――在c++中ctime.h和它一样。
#include<windows.h>         //引用图形设备接口函数，为了使用改变字体颜色的color()函数 

void color(short x)         //自定义函数根据参数改变颜色
{    
	if(x>=0&&x<=15)                   //参数在0-15的范围颜色
		SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),x);//改变字体颜色     
	else
    	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),7);//默认白色
}

void main()
{
	int *lieshu,key,counthang,i,**liehang=(int**)malloc(sizeof(int*)),countlie,KEY,fakehang,tag,locationcorrect,numbercorrect,j,randnum,TAG,timer,length=4,shift=0;
	clock_t start,finish;                    //初始化时钟
	color(12);
	printf("\n\n\n\"Warning：Here comes the problem !!!\"――");
	color(3);
	printf("\n\n\n         \\************* 《从1阶到9阶的10维解密游戏》_v1.03_beta *************/\n\n  \"In order to get the right code, you have to test your wrong codes.\"\n                                                                         ―― Coded By xcz. (2019/10/12)");
	color(7);
	printf("\n\n\n                        \\--------------游戏规则--------------/\n\n\n 1.第一局游戏默认为4阶10维，通关后可玩1~9阶。\n\n 2.n阶10维玩法：0~9共10个数中，随机n位数密码（两两不同）已生成，请输入n个的数字（两两不同）试探其正确性。\n\n 3.输入完毕不用按回车键，每键入n个数字，程序均会自动与the standard code比较并提示。\n\n 4.第n+1、n+2位数分别提示你有多少个数字位置错误但数值是n位密码之一、数值和位置均正确（完全正确）。\n\n 5.错了则继续输入新的一组数字，直到正确，看看你的逻辑帮你到达真理需要多少步，以及花费多少时间。\n\n 6.游戏胜利后：前[(n+1)/2]个数显示你用了多少步、接着[n/2]+1个数显示你用了多少时间（/s），最后一位永远是9。");
	color(11);
	printf("\n\n\n                         \\--------------功能键--------------/        ――“乱按键盘是允许的，但程序是金刚不坏的。”\n\n\n a.↑↓键：翻页查看历史记录。\n\n b.退格键：删除你输入的上一个数字，以便重新输入该数字。\n\n c.ESC键：退出；任何时候都可以退出。\n\n d.猜对密码后：输入1~9中任意数字键重玩对应阶的游戏，也可按↑↓键查看历史记录。\n\n e.k键（小写）：激活/关闭作弊。");
	color(6);
	printf("\n\n\n    \\---You can hardly get through this door, before you really understand sth.---/\n\n\n");
Restart:
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――第一个while：新游戏
	while(1)                                 //重新开始玩新的一局游戏！
	{
		timer=0;                                       //计时器归零
		TAG=0;                                         //若不加这一行，则上一局的最后4位数输入完毕后，进入下一局时，TAG还保持着=1，因为默认是输入错误并且另起炉灶新的一行。
		counthang=0;                                   //初始化行数（不是简单地重置行序号为0，而是清空所有行，并取行序号为0。――这体现在*传送门1*那里）
		lieshu=(int*)malloc(length*sizeof(int));       //length个随机数占length(=1~9)个地址
		srand((unsigned)time(NULL));                   //每次进入该循环，都以当前距离1970年1月1日0时0分0秒，过的秒数，播种种子序列。――注：time(0)与time(null)若在同一时刻调用，返回的值一样【比较time(NULL)和time(0),没有多大意义】；然后将其强转为unsigned  int类型，其取值范围缩减为了0~length+25535，再作为参数给srand()，它的参数需要是unsigned int类型。
		for(j=0;j<length;j++)                          //我需要在0~9间，随机找length个不重复的数字
		{
			while(1)                                             //需要随机到与储存的随机数字不同的数字，才给我出来
			{
				randnum=rand()%10;                                         //获取一个0~9之间的随机数，临时储存下来。――rand()：根据紧邻的上一个srand()的函数值，在0~327length+27之间返回随机数
				for(i=0;i<j;i++)                                           //查看randnum是否与0~j-1对应的，list[i]中前j-1个数中，任何一个相同。
					if(lieshu[i]==randnum)
						break;                                                                 //若有重复的，则提前break掉for循环，并且不满足j==i条件，而重新进入while(1)的开头，继续随机，直到随机到一个与之前存储的没有重复的。
				if(i==j)                                                   //若能进入该if，则i会加到j（j的最大值是3），且该randnum与list[i]中i=j-1及其之前的数字都不重复的，因此将其保存到最新的list[j]中。
			    {
				    lieshu[j]=randnum;                                               //将length个0~9的、且每一个都与前面所有的不同的，随机数，存入lieshu[0]、lieshu[1]、lieshu[2]、lieshu[3]...中。
//					printf("%d\n",lieshu[j]);                                        //调试用；亦或是作弊按钮。
					break;                                                           //这个break是break掉while，开始执行for循环中下一个j值的while，直到下一个不重复的随机数被找出来。
				}
			}
		}
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――第二个while：新行
		while(1)								       //重新猜，猜错了继续猜！
		{
			countlie=0;                                          //重置列序号为0（不是初始化列数）
			counthang++;                                         //行序号+1
			liehang=(int**)realloc(liehang,counthang*sizeof(int*));//在此行序号对应的行处，开辟1个新行。（*传送门1*）――这里用malloc不知道为什么不行，按理说malloc也不会改变以前已经分配了的地址的值，因为我的其他程序中它就没有问题；我是真的服，同样的含义，realloc就不存在这个问题。――按理说直接写liehang=(int**)malloc(counthang*sizeof(int*))也可，只不过相对于realloc最后需要释放指针罢了，不过程序运行结束会自动释放指针，所以这方面用malloc代码长度也没有增加，甚至比realloc更少：它不需要在前面定义变量时引入malloc，只需要写个**liehang定义一个数组就行。
			liehang[counthang-1]=(int*)malloc((length+2)*sizeof(int));//每一个行开辟length+2个列，拿来存整数：六列数字对应六个数码管，length+2个列表示在时间流中的一行行length+2个数字的一维数组。――这个不涉及到以前分配的地址，所以不管malloc对以前的地址的值有没有初始化，这句话都可以不修改。
			for(i=0;i<length+2;i++)
				liehang[counthang-1][i]=10;                                //初始化每个尚且还没有数字的空格的数值为10，用以之后（*传送门2*）判断这里“有没有这个数字”：即若对应单元格的数值等于10，则肯定没有输入数字或者没有给出对错判断(最后两位数)，若没有则不显示这个数字。
//			printf("\r");                                        //“打广告”or做新显示之前得删行，以模拟单片机的显示模式，或者提高游戏难度= =~！*2――后来发现这绿色的多余了就注释掉了。
//			for(i=0;i<length+2;i++)                              //打印该行所在的length+2个列所在的length+2个数字――在这里是打印length+2个空格，以便输入数字。
//			{
//				if(liehang[counthang-1][i]==10)
//					printf("_ ");
//				else                                             //在这里else没用= =，但这printf("\r")及其往下的8行是模板，我就照着copy过来了，做个大自然的搬运工。
//					printf("%d ",liehang[counthang-1][i]);
//			}
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――第三个while：新列
			while(1)                                             //开始捕获用户输入，直到输入length个数字（输入完毕后不用按enter，程序自动对比randnum，判断是否正确，不正确则break，返回上一个while，新建一个行，重新猜）
			{
				tag=0;                                                     //每输入一个数字，都要将下一个数字的tag设为0，即默认下一次键入的按键不是数字，而是功能键、功能键中的上下键or字母；只有当按了数字，才能让tag=1，并因此不执行goto lab重新键入，而因输入了有效按键而来到这里又使tag=0，以期输入下一个数字按键。
				countlie++;                                                //列序号+1
				if(countlie>length)				                           //如果countlie>length了，则已经输入完了，则进入if的另一个分支，与lieshu[0]~lieshu[length-1]进行对比并break出当前所在的while循环。――我直接采用了输入length个数字就自动判断的游戏模式，无需按enter，加快游戏节奏+懒人福音+提高游戏难度。
				{
					locationcorrect=0;				                                 //挨个比较输入的length个数与所生成的length个随机数在位置和正确性上均匹配的数的个数。
					for(i=0;i<length;i++)                                    
					{
						if(liehang[counthang-1][i]==lieshu[i])
							locationcorrect++;
					}
					liehang[counthang-1][length+1]=locationcorrect;
					numbercorrect=0;				                                 //挨个比较输入的length个数与所生成的length个随机数，这两个集合的交集个数。
					for(j=0;j<length;j++)
					{
						for(i=0;i<length;i++)
						{
							if(liehang[counthang-1][i]==lieshu[j])                                       //实际上如果在集合1中找到了一个与集合2相同的数，则接下来对集合1的遍历（j）照常往下取数进行，但对集合2（j）的遍历，就不需要再与相同j值的lieshu[j]比较了。――但这样写比较简单，直接0~3的j++；不然还要加条件判断以跳过相应的j和lieshu[j]，麻烦。――由于两个集合中，每个集合中的元素都是互不相同的，所以不存在i往后去还会使得numbercorrect++的可能。
							{
								numbercorrect++;
								break;                                                                             //为了减小计算机资源占用量，直接break掉第一层for循环，直接第二层for循环中j++。
							}
						}
					}
					liehang[counthang-1][length]=numbercorrect;
					printf("\r");                                                    //“打广告”or做新显示之前得删行，以模拟单片机的显示模式，或者提高游戏难度= =~！
					for(i=0;i<length+2;i++)                                          //打印该行所在的length+2个列所在的数字。――注意：在这之前是刚刚才打印了length个数字，所以现在是立马再打印length+2个数字，有一个flash。――我懒的搞增加判断语句以代码长度，或者为了增加“一闪”这种揭晓答案的紧张感和神秘感，所以我保留这个特性。
					{
						if(liehang[counthang-1][i]==10)
							printf("_ ");
						else
							printf("%d ",liehang[counthang-1][i]);
					}
					if(locationcorrect==length)                                      //the final test――检验你娃娃输入的最终结果是否正确！――如果正确了，那么它会再flash一次（加上这次总共闪了2次了），加入一行新的行，告诉你，加上最后一步你用了多少步才得到正确结果。并且暂时保留历史记录，以便你可以回溯你过去都干过什么傻事= =，按enter键继续下一场新的解谜/密游戏。
					{
						finish=clock();                                                        //一旦length个数字都正确，就马上记录下时间
						counthang++;                                                           //沿用第二层while的初始语句，但不需要重置列序号为0，因为游戏已经结束了。
						liehang=(int**)realloc(liehang,counthang*sizeof(int*));
						liehang[counthang-1]=(int*)malloc((length+2)*sizeof(int));
						if(length==1)                                                          //1+1+1
						{
							liehang[counthang-1][0]=(counthang-1)/1%10;                            //第一位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][1]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第二位改成秒数的个位
							liehang[counthang-1][2]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==2)                                                          //1+2+1
						{
							liehang[counthang-1][0]=(counthang-1)/1%10;                            //第一位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][1]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第二位改成秒数的十位
							liehang[counthang-1][2]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第三位改成秒数的个位
							liehang[counthang-1][3]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==3)                                                          //2+2+1
						{
							liehang[counthang-1][0]=(counthang-1)/10%10;                           //要用counthang-1，因为这多生成的一行是拿来显示信息的，而不是实际的失败次数；第一位改成counthang-1的十位，它可以是0
							liehang[counthang-1][1]=(counthang-1)/1%10;                            //第二位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][2]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第三位改成秒数的十位
							liehang[counthang-1][3]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第四位改成秒数的个位――不关心秒数的千位，即不关心数码管的最后一位，龟速了都，没有意义。
							liehang[counthang-1][4]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==4)                                                          //2+3+1
						{
							liehang[counthang-1][0]=(counthang-1)/10%10;                           //要用counthang-1，因为这多生成的一行是拿来显示信息的，而不是实际的失败次数；第一位改成counthang-1的十位，它可以是0
							liehang[counthang-1][1]=(counthang-1)/1%10;                            //第二位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][2]=(finish-start)/CLOCKS_PER_SEC/100%10;          //第三位改成秒数的百位
							liehang[counthang-1][3]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第四位改成秒数的十位
							liehang[counthang-1][4]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第五位改成秒数的个位――不关心秒数的千位，即不关心数码管的最后一位，龟速了都，没有意义。
							liehang[counthang-1][5]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==5)                                                          //3+3+1
						{
							liehang[counthang-1][0]=(counthang-1)/100%10;                          //counthang-1的百位
							liehang[counthang-1][1]=(counthang-1)/10%10;                           //要用counthang-1，因为这多生成的一行是拿来显示信息的，而不是实际的失败次数；第一位改成counthang-1的十位，它可以是0
							liehang[counthang-1][2]=(counthang-1)/1%10;                            //第三位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][3]=(finish-start)/CLOCKS_PER_SEC/100%10;          //第四位改成秒数的百位
							liehang[counthang-1][4]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第五位改成秒数的十位
							liehang[counthang-1][5]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第六位改成秒数的个位――不关心秒数的千位，即不关心数码管的最后一位，龟速了都，没有意义。
							liehang[counthang-1][6]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==6)                                                          //3+4+1
						{
							liehang[counthang-1][0]=(counthang-1)/100%10;                          //counthang-1的百位
							liehang[counthang-1][1]=(counthang-1)/10%10;                           //要用counthang-1，因为这多生成的一行是拿来显示信息的，而不是实际的失败次数；第一位改成counthang-1的十位，它可以是0
							liehang[counthang-1][2]=(counthang-1)/1%10;                            //第二位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][3]=(finish-start)/CLOCKS_PER_SEC/1000%10;         //第三位改成秒数的千位
							liehang[counthang-1][4]=(finish-start)/CLOCKS_PER_SEC/100%10;          //第四位改成秒数的百位
							liehang[counthang-1][5]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第五位改成秒数的十位
							liehang[counthang-1][6]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第六位改成秒数的个位――不关心秒数的千位，即不关心数码管的最后一位，龟速了都，没有意义。
							liehang[counthang-1][7]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==7)                                                          //4+4+1
						{
							liehang[counthang-1][0]=(counthang-1)/1000%10;                         //counthang-1的千位
							liehang[counthang-1][1]=(counthang-1)/100%10;                          //counthang-1的百位
							liehang[counthang-1][2]=(counthang-1)/10%10;                           //要用counthang-1，因为这多生成的一行是拿来显示信息的，而不是实际的失败次数；第二位改成counthang-1的十位，它可以是0
							liehang[counthang-1][3]=(counthang-1)/1%10;                            //第四位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][4]=(finish-start)/CLOCKS_PER_SEC/1000%10;         //第五位改成秒数的千位
							liehang[counthang-1][5]=(finish-start)/CLOCKS_PER_SEC/100%10;          //第六位改成秒数的百位
							liehang[counthang-1][6]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第七位改成秒数的十位
							liehang[counthang-1][7]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第八位改成秒数的个位――不关心秒数的千位，即不关心数码管的最后一位，龟速了都，没有意义。
							liehang[counthang-1][8]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==8)                                                          //4+5+1
						{
							liehang[counthang-1][0]=(counthang-1)/1000%10;                         //counthang-1的千位
							liehang[counthang-1][1]=(counthang-1)/100%10;                          //counthang-1的百位
							liehang[counthang-1][2]=(counthang-1)/10%10;                           //要用counthang-1，因为这多生成的一行是拿来显示信息的，而不是实际的失败次数；第二位改成counthang-1的十位，它可以是0
							liehang[counthang-1][3]=(counthang-1)/1%10;                            //第四位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][4]=(finish-start)/CLOCKS_PER_SEC/10000%10;        //第五位改成秒数的万位
							liehang[counthang-1][5]=(finish-start)/CLOCKS_PER_SEC/1000%10;         //第六位改成秒数的千位
							liehang[counthang-1][6]=(finish-start)/CLOCKS_PER_SEC/100%10;          //第七位改成秒数的百位
							liehang[counthang-1][7]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第八位改成秒数的十位
							liehang[counthang-1][8]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第九位改成秒数的个位――不关心秒数的千位，即不关心数码管的最后一位，龟速了都，没有意义。
							liehang[counthang-1][9]=9;                                             //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						if(length==9)                                                          //5+5+1
						{
							liehang[counthang-1][0]=(counthang-1)/10000%10;                        //counthang-1的万位
							liehang[counthang-1][1]=(counthang-1)/1000%10;                         //counthang-1的千位
							liehang[counthang-1][2]=(counthang-1)/100%10;                          //counthang-1的百位
							liehang[counthang-1][3]=(counthang-1)/10%10;                           //要用counthang-1，因为这多生成的一行是拿来显示信息的，而不是实际的失败次数；第二位改成counthang-1的十位，它可以是0
							liehang[counthang-1][4]=(counthang-1)/1%10;                            //第五位改成counthang-1的个位――我不关心数码管的第三位，即你如果100步以内都没有猜出来...这...我们就只显示你所用的十位数和个位数吧...
							liehang[counthang-1][5]=(finish-start)/CLOCKS_PER_SEC/10000%10;        //第六位改成秒数的万位
							liehang[counthang-1][6]=(finish-start)/CLOCKS_PER_SEC/1000%10;         //第七位改成秒数的千位
							liehang[counthang-1][7]=(finish-start)/CLOCKS_PER_SEC/100%10;          //第八位改成秒数的百位
							liehang[counthang-1][8]=(finish-start)/CLOCKS_PER_SEC/10%10;           //第九位改成秒数的十位
							liehang[counthang-1][9]=(finish-start)/CLOCKS_PER_SEC/1%10;            //第十位改成秒数的个位――不关心秒数的千位，即不关心数码管的最后一位，龟速了都，没有意义。
							liehang[counthang-1][10]=9;                                            //最后一位改为9，配合最后一位显示位置（全部）正确的数量，则无论是1~9（不能是0~9[因为有10位。10个都正确时，数码管无法显示]，不能是?~10[因为出现了10，数码管限制，人们无法输入10；所以不能出现10]）的猜密码游戏（但是你输入的数却可以是0~9这10个数...不知道你蒙了么；我的游戏比市面上的稍微复杂一点，阶数都是4，但维数从9变成了10，这样10%4=2要比9%4=1难），都可以作为结束标志了。
						}
						printf("\r");                                                          //“打广告”or做新显示之前得删行，以模拟单片机的显示模式，或者提高游戏难度= =~！*3
						for(i=0;i<length+2;i++)                                                //打印该行所在的length+2个列所在的length+2个数字――在这里是打印祝贺词or羞辱语（所用步骤太多）= =。
						{
							if(liehang[counthang-1][i]==10)                                              //这里倒是变成if括号里恒为假而没用了= =，反而else是恒成立的= =...。
								printf("_ ");
							else
								printf("%d ",liehang[counthang-1][i]);
						}
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――已经加入查看历史记录、退出、重开一局机制
						fakehang=counthang;
LAB:
						key=getch();                                                           //暂停当前线程，获取当前热键
//						printf("%d",key);                                                      //调试
						if(key==224)                                                           //用getch读取方向键和功能键时，第一次读是0或者0xE0（这里好像永远是224），第二次读才返回真正的键值，所以需要读取两次；在第一次读的时候，要么返回0要么返回224；――getch一次只能读一个字节，读不了两个字节的功能键。
						{
							KEY=getch();                                                                 //这里允许你输入上下键，以察看对以前的行的历史记录。
//							printf("%d",KEY);                                                            //调试
							switch(KEY)
							{
								case 72:                                                                           //若你按了上键
									fakehang--;                                                                              //必须新建一个fake行，用以查看而非编辑的视角查看以前的行；而不是改变counthang。
//									printf("%d",fakehang);                                                                   //调试
									if(fakehang<1)                                                                           //防止减过度了，若counthang=1，或者fakehang自己减到1了，则得将变成0的fake行加回1来。
										fakehang++;                                                                                    //只有当当前视角所在行数>0时候才能往前跳转；等于0不能再往前跳了
//									printf("%d",fakehang);                                                                   //调试
									printf("\r");                                                                            //删除本行（其实是覆盖输出!!!）
									for(i=0;i<length+2;i++)                                                                            //打印fake行所在的length+2个列所在的数字
									{
										if(liehang[fakehang-1][i]==10)                                                                 //如果fakehang恰好是counthang,则有可能出现还没有输入or获取该新行的一些列的数值，那么对于对应的格子，应该显示_，而不是空格――因为显示空格会与分隔符空格相混淆。（*传送门2*）――我草，如果刚输入完4个，则创建了新行，但新行居然没有定义就开始应用地址了。
											printf("_ ");
										else
											printf("%d ",liehang[fakehang-1][i]);
									}
//									printf("emm");
									goto LAB;                                                                                //这里不用break，而用goto lab，因为break后会到countlie++之前开始执行，这不行，我们还没输入有效数字呢！所以要在countlie++之后开始执行。――若要用break是指跳出switch而不是跳出for！
								case 80:                                                                           //若你按了下键
									fakehang++;
									if(fakehang>counthang)                                                                   //防止加过度了，最多加到counthang即当前要输入的行。
										fakehang--;
									printf("\r");
									for(i=0;i<length+2;i++)
									{
										if(liehang[fakehang-1][i]==10)
											printf("_ ");
										else
											printf("%d ",liehang[fakehang-1][i]);
									}
									goto LAB;
								default:goto LAB;                                                                  //若你按了了除了上下键之外的其他功能键，给我重新输入。
							}
						}
						else if(key==27)                                                       //若你按下了ESC键
							return;
						else
						{
							for(i=1;i<10;i++)                                                            //看看热键是哪个数字
							{
								if(key==48+i)                                                                      //看看是否输入了数字键1~9
								{
									printf("\r                                                \r");                //同志，记着清行――\r+32个空白字符再+\r，好东西，真的：先把光标移到最前，然后覆盖输入32个字符（擦除），然后再把光标移到最前。
									length=key-48;
									goto Restart;
								}
							}
							goto LAB;                                                                    //否则若输入了其他非功能键字符，给我重新输入!
						}
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――已经加入查看历史记录、退出、重开一局机制
					}
					else
					{
						TAG=1;                                                                 //跳出while后counthang会++，但显示的仍然是length+2个有数的当前行而不是length+2个空白的新行，所以需要抵消掉这一差距，在这里设置存档点，往回时光追溯fakehang--。
						break;                                                                 //你还是输错了，break掉它所在的while，继续暗无天日地输入新的行。
					}
				}
				else
				{
					fakehang=counthang;                                              //要在lab之前设置一个fakehang=counthang，否则每次跳到lab，往下走必然遇到fakehang=counthang，这样导致每次fakehang--之后又回到counthang了；而在fakehang--之外设置这个fakehang=counthang，就是为了每次输入了有效数字之后，屏幕会刷新显示最新的行，于是查看视角也得从之前的行挪回来，否则不人性化。
//					printf("%d",counthang);                                          //调试
					if(TAG==1)                                                       //若输入完了某一行，并且没有成功猜对密码，那么counthang会++并储存空数，但显示的仍然是length+2位数的错误结果（以供给玩家查看，不然结果一下就跳过去了）；那么在fakehang获取到的counthang不是当前行，而是当前行+1的新行序列号，需要往回追溯即-1；不用担心刚开始输进来的时候counthang=1的事情，会不会减为-1然后又加为0，因为只有当完成了第一次判断后，TAG才会变成1，在此之前没有输入完成4个数字时，都是0。――只有输入了4个数字，该条件才能触发该语句，即视角行上移，这是因为只有当输入了4个数字后，视角行才与counthang错位了。――所以其他按键、其他条件，均不能触发它。――所以只需要在触发完毕后，在其后面加一个TAG=0即可，其他地方不需要加TAG=0，是多余的；也没有地方能加TAG=1。因为只能有这一个触发开关or机制。
						fakehang--;
					TAG=0;                                                           //及时清零，否则在输入完length个字后，连按4次↑，会往上跳1+2+2+2行...――注：以上这三行要放在lab:后面，不能放在lab前面、fakehang=counthang后面，否则由于键入数字和键入退格那里用的是goto lab，则其中的TAG=0虽然确实改变了TAG的值，但无法sendmessage到lab上面的if(TAG=1)中去执行fakehang--，结果就是TAG确实变成了1，但fakehang仍然没有--...emm...下面TAG=0就是为了不要让fakehang--（因为按了数字或backspace后，视角所在的行fakehang已经是新行了，二者重合了没有错位），所以这3句还是可以拿到lab上面去的，并且为了百分百不让数字和退格引起fakehang--而最好拿上去。甚至我们还可以把下面的两个TAG=0删了，没用，只要下面不出现TAG=1就行。
lab:
					key=getch();                                                     //暂停当前线程，获取当前热键
					timer++;                                                         //每次运行到这里，timer就累加。
					if(timer==1)                                                     //只有当第一次来到这里时，才能进入if进行时间启动
						start=clock();                                               //开始计时
//					printf("%d",key);                                                //调试
					if(key==224)                                                     //用getch读取方向键和功能键时，第一次读是0或者0xE0（这里好像永远是224），第二次读才返回真正的键值，所以需要读取两次；在第一次读的时候，要么返回0要么返回224；――getch一次只能读一个字节，读不了两个字节的功能键。
					{
						KEY=getch();                                                           //这里允许你输入上下键，以察看对以前的行的历史记录。
//						printf("%d",KEY);                                                      //调试
						switch(KEY)
						{
							case 72:                                                                     //若你按了上键
								fakehang--;                                                                        //必须新建一个fake行，用以查看而非编辑的视角查看以前的行；而不是改变counthang。
//			                    printf("%d",fakehang);                                                             //调试
								if(fakehang<1)                                                                     //防止减过度了，若counthang=1，或者fakehang自己减到1了，则得将变成0的fake行加回1来。
									fakehang++;                                                                              //只有当当前视角所在行数>0时候才能往前跳转；等于0不能再往前跳了
//								printf("%d",fakehang);                                                             //调试
								printf("\r");                                                                      //删除本行（其实是覆盖输出!!!）
								for(i=0;i<length+2;i++)                                                            //打印fake行所在的length+2个列所在的数字
								{
									if(liehang[fakehang-1][i]==10)                                                           //如果fakehang恰好是counthang,则有可能出现还没有输入or获取该新行的一些列的数值，那么对于对应的格子，应该显示_，而不是空格――因为显示空格会与分隔符空格相混淆。（*传送门2*）――我草，如果刚输入完4个，则创建了新行，但新行居然没有定义就开始应用地址了。
										printf("_ ");
									else
										printf("%d ",liehang[fakehang-1][i]);
								}
								shift=0;														                   //下一次按k则显示密码
//								printf("emm");
								goto lab;                                                                          //这里不用break，而用goto lab，因为break后会到countlie++之前开始执行，这不行，我们还没输入有效数字呢！所以要在countlie++之后开始执行。――若要用break是指跳出switch而不是跳出for！
							case 80:                                                                     //若你按了下键
								fakehang++;
			                    if(fakehang>counthang)                                                             //防止加过度了，最多加到counthang即当前要输入的行。
									fakehang--;
								printf("\r");
								for(i=0;i<length+2;i++)
								{
									if(liehang[fakehang-1][i]==10)
										printf("_ ");
									else
										printf("%d ",liehang[fakehang-1][i]);
								}
								shift=0;													          	         //下一次按k则显示密码
								goto lab;
							default:goto lab;                                                            //若你按了了除了上下键之外的其他功能键，给我重新输入。――不加shift=0，因为这里没有改变行，没有重新覆盖打印，则下一次按k是否显示密码取决于你之前看了k没有，若按了则关闭显示密码。
						}
					}
					else if(key==8)                                                  //若你按下了退格键
					{
						fakehang=counthang;                                                    //按了退格键后，下次调换视角的时候从最后一行开始（往上）调
//多余					TAG=0;                                                                 //只要按了退格键，则已经在最新的一行（要么在新行删不动第一列，要么在原行删前三位数）操作数字了，所以counthang就是现在的行，没有问题；所以此时必须把TAG修正回来；否则会出现之前TAG=1时若没有马上用掉它，即若刚输完4个数字，没有马上按上下键查看的话，之后在下一行输入字母且往回查看的时候，第一次按↑会多退回一行...。
						if(countlie>1)                                                         //若countlie=1。第一个数字都没有输入，在等待输入第一个，则啥也不干，只管打印输出，然后goto lab继续等待输入；若TAG=1，即刚输入完4位数，则其实此时的光标早就移动到下一行的首列了，此时按退格相当于进入另起炉灶下一行，对下一行的首列按退格，即显示下一列的所有空格= =哈哈，被自己的眼睛骗了吧。――当然不能对已判断了的结果再进行更改，不然这就相当于作弊，在试错！每次已经输入了的4位数，任何一位都不允许被更改，他将作为失败+1，被暂时地永久保存于历史记录清单里。
						{
							liehang[counthang-1][countlie-2]=10;                                         //同一行的，将要输入的空的列，的上一个列，恢复为缺省值10，即相当于其没有输入
							countlie--;                                                                  //将要输入的空的列，变为上一个列
						}
						printf("\r");                                                          //不要忘了删行，以追求极致地模仿单片机的length+2个数码管。
						for(i=0;i<length+2;i++)                                                          //打印该行所在的length+2个列中，所在的数字
						{
							if(liehang[counthang-1][i]==10)
								printf("_ ");
							else
								printf("%d ",liehang[counthang-1][i]);
						}
						shift=0;														                 //下一次按k则显示密码
						goto lab;                                                                        //回到标签处；不需要额外加入tag=0，tag会保持0不变。因为只有在输入非功能键的时候会找数字，找数字的时候才会有是否找到了真数字一说，才是否有tag=1=0一说。
					}
					else if(key==27)                                                           //若你按下了ESC键，则结束程序――你在玩游戏的时候也允许退出，毕竟出于人道主义，可能你妈妈真的喊你吃饭了。
						return;
					else if(key==107)                                                          //若你按下了k(key)键
					{
						if(shift%2==0)                                                                   //如果k键被按奇数次，则在视角行显示正确的密码。
						{
							printf("\r");
							for(i=0;i<length;i++)
								printf("%d ",lieshu[i]);
							shift=1;                                                                     //下一次按k则复原
						}
						else                                                                             //如果k键被按偶数次，则恢复视角行所在的原来的数字。――也可通过其他方法来恢复视角行原数字。
						{
							printf("\r");
							for(i=0;i<length+2;i++)
							{
								if(liehang[fakehang-1][i]==10)
									printf("_ ");
								else
									printf("%d ",liehang[fakehang-1][i]);
							}
							shift=0;                                                                     //下一次按k则显示密码
						}
						goto lab;                                                                        //记住不要忘了加上goto lab;
					}
					else
					{
						for(i=0;i<10;i++)                                                      //看看热键是哪个数字
						{
							if(key==48+i)                                                                //看看是否输入了数字键（有可能会输入其他如退格键、字母等非功能按键；我tm好奇退格键居然不是功能键）
							{
								for(j=0;j<countlie-1;j++)
								{
									if(key==liehang[counthang-1][j]+48)                                                      //看看这些数字键是否与旧有的重合，若是同一行中，以前输入的数字子集，则goto lab重新输入；否则若与每个之前的都不同，则for循环进行完毕，接下来顺其自然进行录入工作。
										goto lab;
								}
								liehang[counthang-1][countlie-1]=key-48;                                           //若匹配到了对应的数字，则贮存在对应行、列的数组里，并且马上退出for循环，不用去匹配10个数字中剩下的，以免浪费计算机资源――并马上跳转到goto lab上面的countlie++处，而不是进入goto lab。
								printf("\r");                                                                      //还是得删行
								for(i=0;i<length+2;i++)                                                                      //打印true行所在的length+2个列所在的数字
								{
									if(liehang[counthang-1][i]==10)                                                          //counthang有可能出现还没有输入or获取该新行的一些列的数值，那么对于对应的格子，应该显示_，而不是空格――因为显示空格会与分隔符空格相混淆。（*传送门2*）
										printf("_ ");
									else
										printf("%d ",liehang[counthang-1][i]);
								}
								tag=1;                                                                   //若真找到了数字，则标记上“找到了数字”。
								shift=0;												          	     //下一次按k则显示密码
//想多了是因if(TAG=1)造成的后果 TAG=0;                                                                   //按退格键或输入其他数字时，反正只要没有在输入上下键，只要在操作数字而不是其他按键，则已经在新的一行操作数字了，所以counthang就是现在的行，没有问题；所以此时必须把TAG修正回来；否则会出现之前TAG=1时若没有马上用掉它，即若刚输完4个数字，没有马上按上下键查看的话，之后在下一行输入字母且往回查看的时候，第一次按↑会多退回一行...。
								break;                                                                   //注意这里break只对最近一层/其所处层的for有用，对if或者上一层的for没用。
							}
						}
						if(tag==0)                                                                       //若“没有找到数字”，则继续找数字
							goto lab;                                                                              //若运行到这里，必然上面的for循环是运行到i=10运行完了的，没有找到数字，没有break。因此此时没有找到数字键，因此输入的按键，是既是功能键外，又是数字键外的按键，比如字母字符。――不加shift=0，理由与之前switch的default处一样。
					}
				}
			}
		}
	}
}
//之所以写这么多注释，一方面体现逻辑的力量；另一方面，我之前写的12个c程序由于没有注释，我自己也很难再看懂了，也没有后继者来看我的程序（尽管即使详细地标记了注释，人们也很难看懂，因为写程序不是从上往下写的，而是往里插的，每一条注释的标注时间没有给出，也就没有给出它们的生成顺序，就不能像小说一样读了；但即使顺序看上去杂乱无章，每一步背后的逻辑的顺序仍然是必要、最简且严密的，当然，只是努力做到最简罢了.――最简的代码不易读，但很聪明）。
//注释格式是缩进的，但是注释的缩进是用空格缩进的，这一点做得不是很好，但毕竟写了这么多了，我就懒的搞改了。以后的程序我会注意这一点，注释的缩进尽量与代码的缩进保持一致，形成分明的层级。

/*更新日志*/

/*--------1.02_beta--------*/
//4替换成length（但要注意48这种键代码），6替换成length+2（这个直接替换即可）――3和5也不用管，因为判断条件我没有用<=，而一直用<。
//显示方式适应变更
//1~9的按键激活1~9阶游戏
//加入多线程时钟函数，以添加作弊功能，但只能看一眼= =

/*--------1.03_beta--------*/
//取消多线程，用常规按键添加作弊功能。
//修正“维-阶”表述bug。
//加入字体颜色。

/*--------1.03_beta--------*/

//再次reverse了阶-维表述。